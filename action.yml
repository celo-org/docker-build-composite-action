name: "Build and Push Docker Image Using Composite Action"
description: >
  This composite action builds a Docker image from a specified Dockerfile and optionally pushes it to a remote registry.
  It supports multi-platform builds, caching, and includes optional tools like Trivy for vulnerability scanning.

inputs:
  runner-platform:
    description: >
      Specifies the platform of the GitHub runner for build testing. Commonly used to test builds on various architectures.
      Default is `linux/amd64`.
    required: false
    default: linux/amd64

  platforms:
    description: >
      Comma-separated list of image platforms to target during the build process (e.g., `linux/amd64,linux/arm64`).
    required: true
    default: linux/amd64

  context:
    description: >
      The build context path for Docker. Typically, this is the directory where the Dockerfile and associated files are located.
    required: true

  dockerfile:
    description: >
      The path to the Dockerfile to use for building the image. This should be relative to the context path.
    required: true

  push:
    description: >
      Indicates whether the image should be pushed to the remote registry. Requires prior authentication to the registry.
      Either `push` or `load` must be set to `true`.
    required: true
    default: 'true'

  build-args:
    description: >
      A list of build-time variables to pass to the Docker build process. Use a comma-separated format.
    required: false

  registry:
    description: >
      The registry to which the image will be pushed (e.g., `docker.io/my-repo` or `ghcr.io/my-org`).
    required: true

  tags:
    description: >
      A comma-separated list of tags to apply to the image. For example, `latest,v1.0,v1.0.0`.
    required: true
    default: latest

  summary:
    description: >
      Enables the generation of a GitHub Action summary for the build process.
    default: 'true'

  pr-comment:
    description: >
      Enables posting comments on pull requests with details about the build process and results.
    default: 'true'

  attestation:
    description: >
      Enables artifact and SBOM attestation generation for the built image.
    default: 'true'

outputs:
  app-name:
    description: >
      The name of the Docker image without the registry. Useful for identifying the application name.
    value: ${{ steps.process_tags.outputs.base_image_name }}

  full-image-name:
    description: >
      The full name of the Docker image, including the registry. This is useful for pulling or referencing the image.
    value: ${{ steps.process_tags.outputs.first_tag }}
runs:
  using: "composite"
  steps:
    - name: Track workflow start time
      id: workflow-start-time
      shell: bash
      run: |
        echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT
        echo "::notice::üöÄ Workflow started at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Conditionally format tags with full image + repo definition
      id: process_tags
      env:
        REGISTRY: ${{ inputs.registry }}
        TAGS: ${{ inputs.tags }}
      shell: bash
      run: |
        START_TIME=$(date +%s)
        echo "::group::Processing tags"
        echo "::notice::‚è±Ô∏è Started processing tags at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

        function process_tags() {
            local processed_tags=()

            # split tag field on comma character and add project + ${{ env.REGISTRY }} + image_name
            IFS=',' read -ra tags <<< "${{ env.TAGS }}"
            for tag in "${tags[@]}"; do
                case "$tag" in
                *:*)
                    # tag includes ':' - assume preprocessed and just pass to output
                    processed_tags+=("$tag")
                    ;;
                *)
                    # tag needs to include full host + repo definition
                    processed_tags+=("${{env.REGISTRY }}:$tag")
                    ;;
                esac
            done

            # format full tags into csv for docker/build-push-action
            output_str=$(printf "%s," "${processed_tags[@]}")


            # export first processed tag in list for trivy scan
            echo "base_image_name=$(basename ${{env.REGISTRY}})" >> $GITHUB_OUTPUT
            echo "first_tag=${processed_tags[0]}" >> $GITHUB_OUTPUT
            echo "processed=$output_str" >> $GITHUB_OUTPUT

            echo "::debug::processed_tags=${processed_tags[@]}"
            echo "::debug::output_str=$output_str"
            echo "::debug::first_tag=${processed_tags[0]}"
        }
        process_tags

        END_TIME=$(date +%s)
        DURATION=$((END_TIME - START_TIME))
        echo "::notice::‚úÖ Tag processing completed in ${DURATION}s"
        echo "::endgroup::"

    - name: Track build start time
      id: build-start-time
      shell: bash
      run: |
        echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT
        echo "::notice::üèóÔ∏è Starting container image build at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

    - name: Build container image and save locally
      uses: docker/build-push-action@v6
      env:
        DOCKER_BUILD_SUMMARY: false
        BUILDKIT_INLINE_CACHE: 1
      id: docker-build
      with:
        platforms: ${{ inputs.runner-platform }}
        file: ${{ inputs.dockerfile }}
        context: ${{ inputs.context }}
        cache-from: |
          type=registry,ref=${{ inputs.registry }}:buildcache
        cache-to: type=inline
        tags: ${{ steps.process_tags.outputs.processed }}
        load: true
        build-args: ${{ inputs.build-args }}

    - name: Track build completion time
      shell: bash
      run: |
        END_TIME=$(date +%s)
        DURATION=$((END_TIME - ${{ steps.build-start-time.outputs.timestamp }}))
        echo "::notice::‚úÖ Container image build completed in ${DURATION}s"

    - name: Scan for OIDC credentials
      shell: bash
      run: |
        START_TIME=$(date +%s)
        echo "::group::Scanning for OIDC credentials"
        echo "::notice::üîç Started OIDC credential scan at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

        set +e
        docker create --name="tmp_container" ${{ steps.docker-build.outputs.imageid }}
        found=$(docker export tmp_container | tar tf - | grep -e "gha-creds-.*.json" | wc -l)
        docker rm tmp_container > /dev/null 2>&1

        END_TIME=$(date +%s)
        DURATION=$((END_TIME - START_TIME))

        if [ $found -ge 1 ]; then
            echo "::error::Found oidc credentials\nAdd the following line to your .dockerignore file\ngha-creds-*.json"
            echo "::notice::‚ùå OIDC scan failed in ${DURATION}s"
        else
            echo "::notice::‚úÖ OIDC scan completed successfully in ${DURATION}s"
        fi

        echo "::endgroup::"
        exit "$found"

    - name: Track build and push start time
      if: ${{ inputs.push }} == true
      id: build-push-start-time
      shell: bash
      run: |
        echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT
        echo "::notice::üöÄ Starting multi-platform build and push at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

    - name: Build and push
      env:
        DOCKER_BUILD_SUMMARY: ${{ inputs.summary }}
        BUILDKIT_INLINE_CACHE: 1
      if: ${{ inputs.push }} == true
      uses: docker/build-push-action@v6
      id: docker-build-push
      with:
        platforms: ${{ inputs.platforms }}
        file: ${{ inputs.dockerfile }}
        context: ${{ inputs.context }}
        push: ${{ fromJSON(inputs.push) }}
        tags: ${{ steps.process_tags.outputs.processed }}
        build-args: ${{ inputs.build-args }}
        cache-from: |
          type=registry,ref=${{ inputs.registry }}:buildcache
          type=inline
        cache-to: type=registry,ref=${{ inputs.registry }}:buildcache,mode=min,oci-mediatypes=true,compression=zstd
        provenance: ${{ fromJSON(false) }}

    - name: Track build and push completion time
      if: ${{ inputs.push }} == true
      shell: bash
      run: |
        END_TIME=$(date +%s)
        DURATION=$((END_TIME - ${{ steps.build-push-start-time.outputs.timestamp }}))
        echo "::notice::‚úÖ Multi-platform build and push completed in ${DURATION}s"

    - name: Track attestation start time
      if: ${{ fromJSON(inputs.attestation) }}
      id: attestation-start-time
      shell: bash
      run: |
        echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT
        echo "::notice::üìú Starting attestation generation at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

    - name: Extract image name from registry for the SBOM attestation artifact name
      if: ${{ fromJSON(inputs.attestation) }}
      id: attestation-artifact-name
      env:
        IMAGE: ${{ steps.process_tags.outputs.first_tag }}
      shell: bash
      run: |
        basename="${IMAGE##*/}"
        stripped_name="${basename%:*}-${basename##*:}"
        echo "name=$stripped_name" >> $GITHUB_OUTPUT

    - name: Generate artifact attestation
      if: ${{ fromJSON(inputs.attestation) }}
      id: attestation
      uses: actions/attest-build-provenance@v2
      with:
        subject-name: ${{ inputs.registry }}
        subject-digest: ${{ steps.docker-build-push.outputs.digest }}
        push-to-registry: true

    - name: Track artifact attestation completion
      if: ${{ fromJSON(inputs.attestation) }}
      shell: bash
      run: |
        END_TIME=$(date +%s)
        DURATION=$((END_TIME - ${{ steps.attestation-start-time.outputs.timestamp }}))
        echo "::notice::‚úÖ Artifact attestation completed in ${DURATION}s"

    - name: Track SBOM generation start time
      if: ${{ fromJSON(inputs.attestation) }}
      id: sbom-start-time
      shell: bash
      run: |
        echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT
        echo "::notice::üìã Starting SBOM generation at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

    - uses: anchore/sbom-action@v0
      if: ${{ fromJSON(inputs.attestation) }}
      id: build-sbom
      with:
        image: ${{ inputs.registry }}@${{ steps.docker-build-push.outputs.digest }}
        output-file: ./sbom.spdx.json
        artifact-name: sbom-${{ steps.attestation-artifact-name.outputs.name }}.spdx.json
        dependency-snapshot: true

    - name: Track SBOM generation completion
      if: ${{ fromJSON(inputs.attestation) }}
      shell: bash
      run: |
        END_TIME=$(date +%s)
        DURATION=$((END_TIME - ${{ steps.sbom-start-time.outputs.timestamp }}))
        echo "::notice::‚úÖ SBOM generation completed in ${DURATION}s"


    - name: Check SBOM size
      if: ${{ fromJSON(inputs.attestation) }}
      id: sbom-size-check
      shell: bash
      # GitHub Actions predicate files must be <= 16MB; skip attestation if too large
      run: |
        START_TIME=$(date +%s)
        FILE="./sbom.spdx.json"
        MAX=16777216
        FILE_SIZE=$(stat -c%s "$FILE")
        echo "::notice::üìè Checking SBOM size: $FILE_SIZE bytes (limit: $MAX bytes)"

        if [ $FILE_SIZE -ge $MAX ]; then
          echo "::warning::SBOM file ($FILE_SIZE bytes) exceeds 16MB limit. Skipping attestation upload."
          echo "skip_attestation=true" >> $GITHUB_OUTPUT
        else
          echo "::notice::‚úÖ SBOM file size is within limits. Proceeding with attestation."
          echo "skip_attestation=false" >> $GITHUB_OUTPUT
        fi

        END_TIME=$(date +%s)
        DURATION=$((END_TIME - START_TIME))
        echo "::notice::‚è±Ô∏è SBOM size check completed in ${DURATION}s"

    - name: Track SBOM attestation start time
      if: ${{ fromJSON(inputs.attestation) && steps.sbom-size-check.outputs.skip_attestation != 'true' }}
      id: sbom-attestation-start-time
      shell: bash
      run: |
        echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT
        echo "::notice::üìã Starting SBOM attestation at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

    - name: Generate SBOM attestation
      if: ${{ fromJSON(inputs.attestation) && steps.sbom-size-check.outputs.skip_attestation != 'true' }}
      uses: actions/attest-sbom@v3
      with:
        subject-name: ${{ inputs.registry }}
        subject-digest: ${{ steps.docker-build-push.outputs.digest }}
        sbom-path: sbom.spdx.json
        push-to-registry: true

    - name: Track SBOM attestation completion
      if: ${{ fromJSON(inputs.attestation) && steps.sbom-size-check.outputs.skip_attestation != 'true' }}
      shell: bash
      run: |
        END_TIME=$(date +%s)
        DURATION=$((END_TIME - ${{ steps.sbom-attestation-start-time.outputs.timestamp }}))
        echo "::notice::‚úÖ SBOM attestation completed in ${DURATION}s"

    - name: Add commands to summary
      if: ${{ fromJSON(inputs.attestation) }}
      shell: bash
      env:
        REGISTRY: "oci://${{ inputs.registry }}@${{ steps.docker-build-push.outputs.digest }}"
      run: |
        # Write Provenance Verification to Summary
        echo "### Attestation Verification" >> $GITHUB_STEP_SUMMARY
        echo "- Verify Provenance" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "gh attestation verify --repo ${{ github.repository }} --signer-repo celo-org/reusable-workflows $REGISTRY --format json | jq" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

        # Write SBOM Verification to Summary
        if [ "${{ steps.sbom-size-check.outputs.skip_attestation }}" != "true" ]; then
          echo "- Verify SBOM" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "gh attestation verify --repo ${{ github.repository }} --signer-repo celo-org/reusable-workflows $REGISTRY --predicate-type https://spdx.dev/Document/v2.3 --format json | jq" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Workflow completion summary
      if: always()
      shell: bash
      run: |
        END_TIME=$(date +%s)
        TOTAL_DURATION=$((END_TIME - ${{ steps.workflow-start-time.outputs.timestamp }}))
        MINUTES=$((TOTAL_DURATION / 60))
        SECONDS=$((TOTAL_DURATION % 60))

        echo "::notice::üéâ Workflow completed at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
        echo "::notice::‚è±Ô∏è Total workflow duration: ${MINUTES}m ${SECONDS}s (${TOTAL_DURATION}s)"

        # Add timing summary to GitHub Step Summary
        {
          echo ""
          echo "### ‚è±Ô∏è Workflow Timing Summary"
          echo "- **Total Duration**: ${MINUTES}m ${SECONDS}s"
          echo "- **Started**: $(date -u -d @${{ steps.workflow-start-time.outputs.timestamp }} +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null || date -u -r ${{ steps.workflow-start-time.outputs.timestamp }} +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null || echo "N/A")"
          echo "- **Completed**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
        } >> $GITHUB_STEP_SUMMARY
